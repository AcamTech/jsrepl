********************************************************************************
*                               Current Tasks                                  *
********************************************************************************

Update jqconsole
  max99x

Work on Ruby
  amasad

********************************************************************************
*                               Brainstorming                                  *
********************************************************************************

jqconsole changes
  Add line continuation support
    With markers!
  Fix paste on Opera
  Read the entire bash manual for inspiration
  Fix loss of focus on text selection
  Add a way to get the position of the cursor in the line (i.e. column)
    Used for tabstop-based tabbing on output
  Add class for previously-entered commands, similar to jqconsole-input
  Input/Output modes breaks some languages asynchronicity

Add a "library" property to the language definition
  Repl.coffee will always load and run it after initializing an engine
  A little extra overhead by makes things neater
  Better let the language keep track and load the library by itself
    No messing with the UI callbacks
    Can be optimized better
  amasad prefers to have it controlled by $LAB and then delegated to the library
    max99x is not a fan of $LAB, but the way amasad did it looks fine
      Would still rather have plaintext libraries written in each language

Examples
  How to load multi-command examples?
    As single command (with auto-growth for multi-lined examples)
    As a session?

Input method
  Line-by-line
    Natural terminal, from top to bottom
    Global hand-written key handler
    Grow automatically
      Shift+Enter
      Let language decide when to grow
        Scheme -> On unbalanced brackets/braces/parantheses
        QBasic -> On unfinished block
      On paste/example load?
      Need to always maintain continuation/indent marker, e.g.:
        >>> def f(x):
        ...   if x:
        ...     return x
        ...   else:
        ...     print 'Error!'
      How to keep history in multi-line
        Some terminals remember lines (e.g. Python)
        Others remember full commands (e.g. bash)
          max99x would opt for this
      NodeJS REPL: 
        when the user presses return on a line of code
        and that line would produce a syntax error
        it will assume that there is lines of code to follow
        and create a continuation marker and keep on doing that
        until the command can be successfully ran or the user presses
        the escape character. 
        This could be used for many of our languages that don't have a 
        way of figuring out code continuation (like python, lisp, scheme..).
      In my(amasad) opinion if the user had a small expandable code editor
      underneath the REPL terminal, he/she could use it for multi-line commands instead of
      going through the pain of the terminal multiline. In my experience with REPL(s)
      not one language I found to have a usable multi-line REPL, but python and BiwaScheme
      and that is because the languages allow for it. Still a pain when it comes to history.
      
  An expanded Rich-Text Editing for code snippets
    http://codemirror.net/
      Will open in a pop-up
        Pop-ups are so last decade!
        Try split screen
        Having it underneath the REPL terminal
        with an expand/minimize button that would minify the terminal
        and expand the editor, should also be resizable. 
      How to handle execution?
        Go through the terminal?
        Go to a different Eval method, for instance EvalMulti?
    What about highlighting?
      Codemirror is extensible - we can add languages that aren't supported

Persistence
  Download
    Session log
    All entered commands as script
  Persistence
    Snippet-like URLs
    Accounts / profiles
      Probably too complex and not really needed
    Embed runnable jsREPL code snippets on sites/blogs
      Sounds impressive and should be reasonably easy
      Maybe an iframe or smart widget that would load only the chosen language

UI Design
  jsREPL Logo 
  Color scheme
  Something to fill in the empty space on first load
    Examples?
    Faint logo?
    Something funny?
      Something funny yet subtle?
  Language-specific help link

Porting:
  Port to Node.js
    Make it accessible from terminal
  Port to Chrome extension (or APP).
  Port to Mozilla extension. 

Exotic Future Features
  External Access
    DOM
    XHR
    Canvas
    Having good canvas support could allow for people to write games
    Or even port games that is written in a language we support
    give them a way to share it (url shortener + result view)
  Server side evaluation
    Security!
    Performance hit due to latency
  Parse tree
  Embed as executable script
    We have VMs for many languages with the same interface
    We can create a standard DOM/XHR/Canvas API accessible from all languages
    A user can script their browser in any language on jsREPL
      Generate an includeable <script> for their page!
    Of course impractical for real projects, but some idiosyncratic fun!

Usage Patterns
  Trying out code while learning a language
  Linking to interactive solutions on sites like StackOverflow.com
  Access from mobile phones
  Prototyping
    Not complex enough so far

Marketing
  Target tutorial writers
  Post good StackOverflow answers with example links to jsREPL sessions
  Make a Chrome App
  Having a large collection of esoteric languages: can attract amateurs (good!)

Is jsREPL still an appropriate name?
  Our non-lib code is Coffee!
  Might confuse people, implying it's just a REPL for JS
  re.pl and repl.{net,org,com} are taken!
    repl.{us,biz,ws,cc} are available, but somewhat meh
  Still have a long time to decide

Testing:
  A standard set of examples that can be applied to all languages.
  Some of the languages we included have their own set of tests, why not use them.

********************************************************************************
*                               More Languages                                 *
********************************************************************************

LISP
  http://kybernetikos.github.com/Javathcript/
    Currently used
  http://www.parkscomputing.com/lisptest.html
  http://joeganley.com/code/jslisp.html
  http://stevela.github.com/js-lisp/
  http://www.ducklet.com/jisp/
  http://www.marcbelmont.com/lisp-interpreter-in-javascript-with-jquery
  http://github.com/willurd/js-lisp
  https://github.com/akapav/js
  https://github.com/mishoo/JCLS

Ruby
  http://coderepos.org/share/wiki/JSRuby
  http://hotruby.yukoba.jp/

Javascript
  Seriously, why haven't we done this one yet?
  Might be a good choice as the default language
    No libs required - instant load!
    People might quickly assume that only JS is supported - NOT what we want

JS.next
  http://code.google.com/p/traceur-compiler/

Haskell
  http://www.tinyrocket.se/2010/05/19/a-haskell-interpreter-in-javascript/
    Seems rather unstable
      Not sure if this can be used at all
      At best we'll need to patch up a fair amount of stuff
        An opportunity to properly learn Haskell!

Bloop
  http://tim-ryan.com/labs/bloopjs/

Befunge
  http://www.quirkster.com/js/befunge.html

Applesoft BASIC
  http://www.calormen.com/applesoft/

6502-compatible Assembler
  http://www.6502asm.com/

Cat
  http://www.cat-language.com/interpreter.html

Forth
  http://wiki.forthfreak.net/index.cgi?jsforth

HQ9+
  http://safalra.com/programming/esoteric-languages/interpreters/hq9-plus/

Prolog
  http://ioctl.org/logic/prolog-latest

Smalltalk
  http://silversmalltalk.wordpress.com/
  http://clamato.net/

Generic Algol-like languages
  http://www.zerny.dk/j-is-for-js.html

Python
  http://code.google.com/p/skulpt/

Lua
  Write a JS Lua interpreter ^^
    But seriously how hard could it be?
      We don't even know Lua as of right now! :D
    Maybe something like a Lua -> JS compiler
    Hardest feature might be coroutines
